#include <sonde2.h>
#include <math.h>

#define CONV_CST 0.48
#define TRESHOLD 10
#define TENS_DISPLAY PIN_E0
#define UNITY_DISPLAY PIN_E1
#define GREEN_LED PIN_C0
#define RED_LED PIN_C1

/**
 * Reset all 7 segments displays
 */
void resetDisplays() {
   output_high(pin_e0);
   output_high(pin_e1);
}

int simpleBCDConverter(value) {
   // Shift tens from 4 bits to the left
   // So we have ([Tens] [Unity]) XXXX XXXX
   return ((value / 10 % 10 << 4) + value % 10);
}

/**
 * Convert a number of 10 bits to its BCD equivalent
 */
void bitsToBCD(int value) {
   int tens = floor(value / 10 % 10);
   int unity = value % 10;
   
   //resetDisplays();
   output_high(TENS_DISPLAY);
   output_d(tens);
   output_low(UNITY_DISPLAY);
   delay_ms(20);
   //resetDisplays();
   output_high(UNITY_DISPLAY);
   output_d(unity);
   output_low(TENS_DISPLAY);
   delay_ms(20);
   
   
}

/**
 * Check temp level, and switch on the right led
 */
void checkLed(int temp) {
   // If temps is greater than treshold
   // Blinking Red LED with 555 (astable)
   if (temp > TRESHOLD) {
      output_high(RED_LED);
   } else { // Otherwise, green LED
      output_high(GREEN_LED);
   }
}

void main()
{
   setup_adc_ports(AN0);
   set_adc_channel(0); // A0 connecté à l'entrée analogique
   setup_adc(ADC_CLOCK_INTERNAL);
   setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1|RTCC_8_BIT); // 51,2 us overflow
   setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); //13,1 ms overflow
   
   setup_low_volt_detect(FALSE);
   
   int temperature;
   int i;
   
   while(TRUE) {
      delay_ms(10);
      // Read the value from A/N converter (10bits [0 => 1023])
      // And convert it to a range from 0 to 100 (°C)
      // 0.48 => (5 / 1023) * 100
      temperature = read_adc() * CONV_CONST;
            
      // Check temp level
      checkLed(temperature);

      // Convert bits to BCD
      // And show temp on 7 segment displays
      bitsToBCD(temperature);
   }

}
